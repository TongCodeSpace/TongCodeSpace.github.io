泛型的好处
- 编译时强类型校验
- 消除强转（在构造时指定类型可以减少强转）
- 让程序员实现通用算法

泛型类型命名规范
- E - Element（被 Java 集合框架广泛使用）
- K - Key
- N - Number
- T - Type
- V - Value
- S, U, V etc - 2 nd, 3 rd, 4 th types

> Parameter VS argument
> Parameter: 声明的参数类型
> Argument: 实际传入的参数
> 当调用一个方法时，我们传入的 argument 必须符合 parameter 的类型和顺序

闪光点
- Java 7 之后，不声明具体类型，也会根据 Type Inference 找到对应的类型

多个类型参数
参数化类型

## 原始类型 （raw types）

前置信息：我们有一个如下的泛型类

```java
public class Box<T> {
	//...
}
```

### 什么是 raw types

为了创建一个参数化的 `Box<T>`，需要为形式类型参数（parameter）提供一个真正的参数（argument），如果省略了实际参数（argument），那么就是原始类型（raw types），非泛型类或接口没有 raw types

```java
//etc
Box box = new Box();
```

在使用 raw types 时会绕过泛型类型检查，将不安全代码的捕获推迟到运行时，因此，我们要尽量避免使用 raw types

### unchecked error

当将一个 raw types 的泛型类赋值给一个具体的泛型类时就会发生 unchecked error

```java
//etc
Box<Integer> bi;
bi = new Box();
//将会提示如下 msg
warning:[unchecked] unchecked conversion
```

解决方案：
1. 使用  `-Xlint:-unchecked` 重新进行编译
2. 使用注解 `@SuppressWarnings("unchecked")`

## 泛型方法

泛型方法时引入自己的类型参数（parameters）的方法

在泛型方法语法中，在返回值中使用到的 type，需要在方法的入参中被定义（放在尖括号中），对于静态方法，类型参数必须出现在返回类型之前

```java
//etc
public class Util {
	public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
		return p1.getKey().equals(p2.getKey);
	}
}

public class Pair<K, V> {
	private K key;
	private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public void setKey(K key) { this.key = key; }
    public void setValue(V value) { this.value = value; }
    public K getKey()   { return key; }
    public V getValue() { return value; }
}

//对 compare 方法的使用
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "banana");
boolean same = Util.<Integer, String>compare(p1, p2); 
// 上一行此处 <Integer, String> 的删除可以去除
```